"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose-unique-validator";
exports.ids = ["vendor-chunks/mongoose-unique-validator"];
exports.modules = {

/***/ "(rsc)/./node_modules/mongoose-unique-validator/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose-unique-validator/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst each = __webpack_require__(/*! lodash.foreach */ \"(rsc)/./node_modules/lodash.foreach/index.js\");\r\nconst get = __webpack_require__(/*! lodash.get */ \"(rsc)/./node_modules/lodash.get/index.js\");\r\nconst merge = __webpack_require__(/*! lodash.merge */ \"(rsc)/./node_modules/lodash.merge/index.js\");\r\n\r\n// Function typecheck helper\r\nconst isFunc = (val) => typeof val === 'function';\r\n\r\nconst deepPath = function(schema, pathName) {\r\n    let path;\r\n    const paths = pathName.split('.');\r\n\r\n    if (paths.length > 1) {\r\n        pathName = paths.shift();\r\n    }\r\n\r\n    if (isFunc(schema.path)) {\r\n        path = schema.path(pathName);\r\n    }\r\n\r\n    if (path && path.schema) {\r\n        path = deepPath(path.schema, paths.join('.'));\r\n    }\r\n\r\n    return path;\r\n};\r\n\r\nconst plugin = function(schema, options) {\r\n    options = options || {};\r\n    const type = options.type || plugin.defaults.type || 'unique';\r\n    const message = options.message || plugin.defaults.message || 'Error, expected `{PATH}` to be unique. Value: `{VALUE}`';\r\n\r\n    // Mongoose Schema objects don't describe default _id indexes\r\n    // https://github.com/Automattic/mongoose/issues/5998\r\n    const indexes = [[{ _id: 1 }, { unique: true }]].concat(schema.indexes());\r\n\r\n    // Dynamically iterate all indexes\r\n    each(indexes, (index) => {\r\n        const indexOptions = index[1];\r\n\r\n        if (indexOptions.unique) {\r\n            const paths = Object.keys(index[0]);\r\n            each(paths, (pathName) => {\r\n                // Choose error message\r\n                const pathMessage = typeof indexOptions.unique === 'string' ? indexOptions.unique : message;\r\n\r\n                // Obtain the correct path object\r\n                const path = deepPath(schema, pathName) || schema.path(pathName);\r\n\r\n                if (path) {\r\n                    // Add an async validator\r\n                    path.validate(function() {\r\n                        return new Promise((resolve, reject) => {\r\n                            const isQuery = this.constructor.name === 'Query';\r\n                            const conditions = {};\r\n                            let model;\r\n\r\n                            if (isQuery) {\r\n                                // If the doc is a query, this is a findAndUpdate.\r\n                                each(paths, (name) => {\r\n                                    let pathValue = get(this, '_update.' + name) || get(this, '_update.$set.' + name);\r\n\r\n                                    // Wrap with case-insensitivity\r\n                                    if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\r\n                                        // Escape RegExp chars\r\n                                        pathValue = pathValue.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n                                        pathValue = new RegExp('^' + pathValue + '$', 'i');\r\n                                    }\r\n\r\n                                    conditions[name] = pathValue;\r\n                                });\r\n\r\n                                // Use conditions the user has with find*AndUpdate\r\n                                each(this._conditions, (value, key) => {\r\n                                    conditions[key] = { $ne: value };\r\n                                });\r\n\r\n                                model = this.model;\r\n                            } else {\r\n                                const parentDoc = this.$parent();\r\n                                const isNew = parentDoc.isNew;\r\n\r\n                                if (!isNew && !parentDoc.isModified(pathName)) {\r\n                                    return resolve(true);\r\n                                }\r\n\r\n                                // https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths\r\n                                const isSubdocument = this._id !== parentDoc._id;\r\n                                const isNestedPath = isSubdocument ? false : pathName.split('.').length > 1;\r\n\r\n                                each(paths, (name) => {\r\n                                    let pathValue;\r\n                                    if (isSubdocument) {\r\n                                        pathValue = get(this, name.split('.').pop());\r\n                                    } else if (isNestedPath) {\r\n                                        const keys = name.split('.');\r\n                                        pathValue = get(this, keys[0]);\r\n                                        for (let i = 1; i < keys.length; i++) {\r\n                                            const key = keys[i];\r\n                                            pathValue = get(pathValue, key);\r\n                                        }\r\n                                    } else {\r\n                                        pathValue = get(this, name);\r\n                                    }\r\n\r\n                                    // Wrap with case-insensitivity\r\n                                    if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\r\n                                        // Escape RegExp chars\r\n                                        pathValue = pathValue.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n                                        pathValue = new RegExp('^' + pathValue + '$', 'i');\r\n                                    }\r\n\r\n                                    conditions[name] = pathValue;\r\n                                });\r\n\r\n                                if (!isNew && this._id) {\r\n                                    conditions._id = { $ne: this._id };\r\n                                }\r\n\r\n                                // Obtain the model depending on context\r\n                                // https://github.com/Automattic/mongoose/issues/3430\r\n                                // https://github.com/Automattic/mongoose/issues/3589\r\n                                if (isSubdocument) {\r\n                                    model = this.ownerDocument().model(this.ownerDocument().constructor.modelName);\r\n                                } else if (isFunc(this.model)) {\r\n                                    model = this.model(this.constructor.modelName);\r\n                                } else {\r\n                                    model = this.constructor.model(this.constructor.modelName);\r\n                                }\r\n                            }\r\n\r\n                            if (indexOptions.partialFilterExpression) {\r\n                                merge(conditions, indexOptions.partialFilterExpression);\r\n                            }\r\n\r\n                            // Is this model a discriminator and the unique index is on the whole collection,\r\n                            // not just the instances of the discriminator? If so, use the base model to query.\r\n                            // https://github.com/Automattic/mongoose/issues/4965\r\n                            // eslint-disable-next-line\r\n                            if (model.baseModelName && (indexOptions.partialFilterExpression === null || indexOptions.partialFilterExpression === undefined)) {\r\n                                model = model.db.model(model.baseModelName);\r\n                            }\r\n\r\n                            model.find(conditions).countDocuments()\r\n                                .then((count) => {\r\n                                    resolve(count === 0);\r\n                                })\r\n                                .catch((err) => {\r\n                                    reject(err);\r\n                                });\r\n                        });\r\n                    }, pathMessage, type);\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nplugin.defaults = {};\r\n\r\n// Export the mongoose plugin\r\nmodule.exports = plugin;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UtdW5pcXVlLXZhbGlkYXRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLG9FQUFnQjtBQUNyQyxZQUFZLG1CQUFPLENBQUMsNERBQVk7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLGdFQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsS0FBSyx5QkFBeUIsTUFBTTtBQUN6SDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxJQUFJLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGphbWVzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxjbG9uZS1kZS14XFxmcm9udFxcY2xvbmUteFxcbm9kZV9tb2R1bGVzXFxtb25nb29zZS11bmlxdWUtdmFsaWRhdG9yXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBlYWNoID0gcmVxdWlyZSgnbG9kYXNoLmZvcmVhY2gnKTtcclxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xyXG5jb25zdCBtZXJnZSA9IHJlcXVpcmUoJ2xvZGFzaC5tZXJnZScpO1xyXG5cclxuLy8gRnVuY3Rpb24gdHlwZWNoZWNrIGhlbHBlclxyXG5jb25zdCBpc0Z1bmMgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xyXG5cclxuY29uc3QgZGVlcFBhdGggPSBmdW5jdGlvbihzY2hlbWEsIHBhdGhOYW1lKSB7XHJcbiAgICBsZXQgcGF0aDtcclxuICAgIGNvbnN0IHBhdGhzID0gcGF0aE5hbWUuc3BsaXQoJy4nKTtcclxuXHJcbiAgICBpZiAocGF0aHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHBhdGhOYW1lID0gcGF0aHMuc2hpZnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNGdW5jKHNjaGVtYS5wYXRoKSkge1xyXG4gICAgICAgIHBhdGggPSBzY2hlbWEucGF0aChwYXRoTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhdGggJiYgcGF0aC5zY2hlbWEpIHtcclxuICAgICAgICBwYXRoID0gZGVlcFBhdGgocGF0aC5zY2hlbWEsIHBhdGhzLmpvaW4oJy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn07XHJcblxyXG5jb25zdCBwbHVnaW4gPSBmdW5jdGlvbihzY2hlbWEsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBwbHVnaW4uZGVmYXVsdHMudHlwZSB8fCAndW5pcXVlJztcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgcGx1Z2luLmRlZmF1bHRzLm1lc3NhZ2UgfHwgJ0Vycm9yLCBleHBlY3RlZCBge1BBVEh9YCB0byBiZSB1bmlxdWUuIFZhbHVlOiBge1ZBTFVFfWAnO1xyXG5cclxuICAgIC8vIE1vbmdvb3NlIFNjaGVtYSBvYmplY3RzIGRvbid0IGRlc2NyaWJlIGRlZmF1bHQgX2lkIGluZGV4ZXNcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy81OTk4XHJcbiAgICBjb25zdCBpbmRleGVzID0gW1t7IF9pZDogMSB9LCB7IHVuaXF1ZTogdHJ1ZSB9XV0uY29uY2F0KHNjaGVtYS5pbmRleGVzKCkpO1xyXG5cclxuICAgIC8vIER5bmFtaWNhbGx5IGl0ZXJhdGUgYWxsIGluZGV4ZXNcclxuICAgIGVhY2goaW5kZXhlcywgKGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhPcHRpb25zID0gaW5kZXhbMV07XHJcblxyXG4gICAgICAgIGlmIChpbmRleE9wdGlvbnMudW5pcXVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoaW5kZXhbMF0pO1xyXG4gICAgICAgICAgICBlYWNoKHBhdGhzLCAocGF0aE5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIENob29zZSBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoTWVzc2FnZSA9IHR5cGVvZiBpbmRleE9wdGlvbnMudW5pcXVlID09PSAnc3RyaW5nJyA/IGluZGV4T3B0aW9ucy51bmlxdWUgOiBtZXNzYWdlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9idGFpbiB0aGUgY29ycmVjdCBwYXRoIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlZXBQYXRoKHNjaGVtYSwgcGF0aE5hbWUpIHx8IHNjaGVtYS5wYXRoKHBhdGhOYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbiBhc3luYyB2YWxpZGF0b3JcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnZhbGlkYXRlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNRdWVyeSA9IHRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gJ1F1ZXJ5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RlbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkb2MgaXMgYSBxdWVyeSwgdGhpcyBpcyBhIGZpbmRBbmRVcGRhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChwYXRocywgKG5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGhWYWx1ZSA9IGdldCh0aGlzLCAnX3VwZGF0ZS4nICsgbmFtZSkgfHwgZ2V0KHRoaXMsICdfdXBkYXRlLiRzZXQuJyArIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB3aXRoIGNhc2UtaW5zZW5zaXRpdml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0KHBhdGgsICdvcHRpb25zLnVuaXF1ZUNhc2VJbnNlbnNpdGl2ZScpIHx8IGluZGV4T3B0aW9ucy51bmlxdWVDYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FwZSBSZWdFeHAgY2hhcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IHBhdGhWYWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFZhbHVlID0gbmV3IFJlZ0V4cCgnXicgKyBwYXRoVmFsdWUgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnNbbmFtZV0gPSBwYXRoVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBjb25kaXRpb25zIHRoZSB1c2VyIGhhcyB3aXRoIGZpbmQqQW5kVXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCh0aGlzLl9jb25kaXRpb25zLCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zW2tleV0gPSB7ICRuZTogdmFsdWUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnREb2MgPSB0aGlzLiRwYXJlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05ldyA9IHBhcmVudERvYy5pc05ldztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05ldyAmJiAhcGFyZW50RG9jLmlzTW9kaWZpZWQocGF0aE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3N1YmRvY3MuaHRtbCNzdWJkb2N1bWVudHMtdmVyc3VzLW5lc3RlZC1wYXRoc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU3ViZG9jdW1lbnQgPSB0aGlzLl9pZCAhPT0gcGFyZW50RG9jLl9pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05lc3RlZFBhdGggPSBpc1N1YmRvY3VtZW50ID8gZmFsc2UgOiBwYXRoTmFtZS5zcGxpdCgnLicpLmxlbmd0aCA+IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gocGF0aHMsIChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N1YmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSBnZXQodGhpcywgbmFtZS5zcGxpdCgnLicpLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05lc3RlZFBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBuYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSBnZXQodGhpcywga2V5c1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IGdldChwYXRoVmFsdWUsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSBnZXQodGhpcywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgd2l0aCBjYXNlLWluc2Vuc2l0aXZpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldChwYXRoLCAnb3B0aW9ucy51bmlxdWVDYXNlSW5zZW5zaXRpdmUnKSB8fCBpbmRleE9wdGlvbnMudW5pcXVlQ2FzZUluc2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgUmVnRXhwIGNoYXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSBwYXRoVmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IG5ldyBSZWdFeHAoJ14nICsgcGF0aFZhbHVlICsgJyQnLCAnaScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zW25hbWVdID0gcGF0aFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmV3ICYmIHRoaXMuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMuX2lkID0geyAkbmU6IHRoaXMuX2lkIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPYnRhaW4gdGhlIG1vZGVsIGRlcGVuZGluZyBvbiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzM0MzBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvMzU4OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N1YmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsID0gdGhpcy5vd25lckRvY3VtZW50KCkubW9kZWwodGhpcy5vd25lckRvY3VtZW50KCkuY29uc3RydWN0b3IubW9kZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuYyh0aGlzLm1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWwodGhpcy5jb25zdHJ1Y3Rvci5tb2RlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsID0gdGhpcy5jb25zdHJ1Y3Rvci5tb2RlbCh0aGlzLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZShjb25kaXRpb25zLCBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgbW9kZWwgYSBkaXNjcmltaW5hdG9yIGFuZCB0aGUgdW5pcXVlIGluZGV4IGlzIG9uIHRoZSB3aG9sZSBjb2xsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGp1c3QgdGhlIGluc3RhbmNlcyBvZiB0aGUgZGlzY3JpbWluYXRvcj8gSWYgc28sIHVzZSB0aGUgYmFzZSBtb2RlbCB0byBxdWVyeS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy80OTY1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5iYXNlTW9kZWxOYW1lICYmIChpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gPT09IG51bGwgfHwgaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBtb2RlbC5kYi5tb2RlbChtb2RlbC5iYXNlTW9kZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5maW5kKGNvbmRpdGlvbnMpLmNvdW50RG9jdW1lbnRzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoY291bnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb3VudCA9PT0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcGF0aE1lc3NhZ2UsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnBsdWdpbi5kZWZhdWx0cyA9IHt9O1xyXG5cclxuLy8gRXhwb3J0IHRoZSBtb25nb29zZSBwbHVnaW5cclxubW9kdWxlLmV4cG9ydHMgPSBwbHVnaW47XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mongoose-unique-validator/index.js\n");

/***/ })

};
;